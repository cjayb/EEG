######
#
# This code creates Figure S5 in Eyal et al 2017
# It generates the maximal number of independent NMDA spikes in all six models of this paper
# It rechecks that indeed these spikes are independent and then present all six models
# The code presents the voltage 10 ms after the activation of the NMDA spikes
#
# Note: Due to a visualization bug in NEURON, some of the models are shown without their soma
# This has no effect on the running results, 
# and the figures in the paper were generated by running each model individually
#
# AUTHOR: Guy Eyal, the Hebrew University
# CONTACT: guy.eyal@mail.huji.ac.il
#
########
import os

os.system('nrnivmodl ../mechanisms/')

from neuron import h,gui
import numpy as np
import matplotlib.pyplot as plt
import pandas as pnd
import matplotlib
import pickle
from math import *


from tree_functions import *


h.load_file("import3d.hoc")
h.load_file("nrngui.hoc")




TAU_1_AMPA = 0.3
TAU_2_AMPA = 1.8
# properties of the model from figure 4:
TAU_1_NMDA = 8.019 
TAU_2_NMDA = 34.9884
N_NMDA = 0.28011
GAMMA_NMDA = 0.0765685
AMPA_W = 0.00073027
NMDA_W = 0.00131038
NMDA_W_BLOCKED = 0


E_SYN = 0
E_PAS = -86
Spike_time = 10
DELAY = 0
NUM_OF_SYNAPSES = 1
SPINE_HEAD_X = 1
SECTION_TERMINAL = 1

h.tstop = 100
V_INIT = E_PAS

CLUSTER_LENGTH = 20

VOLTAGE_THRESHOLD_NEAREST_JUNCTION = -40


Stim1 = h.NetStim()
Stim1.interval=10000 
Stim1.start=Spike_time
Stim1.noise=0
Stim1.number=1


def create_model(model_file,morph_file):

    h("objref cell, tobj")
    model_path = "../PassiveModels/"

    h.load_file(model_path+model_file+".hoc")
    h.execute("cell = new "+model_file+"()") 
    nl = h.Import3d_Neurolucida3()
    nl.quiet = 1
    nl.input(morph_file)

    imprt = h.Import3d_GUI(nl,0)
    imprt.instantiate(h.cell)
    HCell = h.cell
    HCell.geom_nseg()
    HCell.create_model()
    HCell.biophys()

    return HCell

# This generates a dictionary that map from each segment in the model to minimal number of synapses 
# needed to be activated in this segment in order to generate NMDA spike
# It is based on the databases in number_of_synapses_to_NMDA_spike 

def seg_to_num_of_syn_per_nmda_spike_func(dict_filename,cell):
    with open(dict_filename, 'rb') as handle:
        d = pickle.load(handle)

    seg_to_nmda_threshold = {}
    for sec in list(cell.basal)+list(cell.apical):
        for seg in list(sec)+[sec(1)]:
            if seg.x == 0:
                continue
            dot_index = str.rfind(sec.hname(),".")
            secname = sec.hname()[dot_index+1:]
            seg_to_nmda_threshold[seg]  = d[(secname,round(seg.x,3))]

    return seg_to_nmda_threshold


# Add spines to the input model
def add_spines_on_segments(HCell,list_of_segments,seg_to_num_of_syn):
    total_synapses = 0

    Xs_vec = h.Vector()
    secs_sref_list = h.List()

    for seg in list_of_segments:
        sec = seg.sec
        num_of_synapses = seg_to_num_of_syn[seg]
        assert num_of_synapses!=0, "segment on %s has 0 synapses"%sec.hname()
        Lsec = sec.L
        sref = h.SectionRef(sec=sec)

        if Lsec > CLUSTER_LENGTH: # distribute the spines on CLUSTER_LENGTH um on the section
            min_x = (Lsec-CLUSTER_LENGTH)/float(seg.x)
        else: # in cases where the section is shorter than CLUSTER_LENGTH
            mix_x = 0

        for ix in range(num_of_synapses):
            secs_sref_list.append(sref)
            x_syn = min_x+ix*CLUSTER_LENGTH/float(num_of_synapses-1)
            Xs_vec.append(min(x_syn/float(Lsec),1))

        total_synapses += num_of_synapses

    HCell.add_few_spines(secs_sref_list,Xs_vec,0.25,1.35,2.8,HCell.soma[0].Ra)

    HCell.soma[0].push()
    return total_synapses




# put excitatory synapses on spine heads in the input model 
# list_of_segments defines the locations
# seg_to_num_of_syn defines the number of synapses to put in each location
def add_synapses_on_list_of_segments(list_of_segments,HCell,SynList,ConList,seg_to_num_of_syn):
    HCell.delete_spine()

    num_of_synapses = add_spines_on_segments(HCell,list_of_segments,seg_to_num_of_syn)

    for j in range(num_of_synapses):

            SynList.append(h.Exp2Syn(SPINE_HEAD_X,sec=HCell.spine[(j*2)+1]))
            ConList.append(h.NetCon(Stim1,SynList[-1]))
            SynList[-1].e=E_SYN
            SynList[-1].tau1=TAU_1_AMPA
            SynList[-1].tau2=TAU_2_AMPA
            ConList[-1].weight[0]= AMPA_W
            ConList[-1].delay = DELAY


    for j in range(num_of_synapses):
        
        SynList.append(h.NMDA(SPINE_HEAD_X,sec=HCell.spine[(j*2)+1]))
        ConList.append(h.NetCon(Stim1,SynList[-1]))
        SynList[-1].e=E_SYN
        SynList[-1].tau_r_NMDA=TAU_1_NMDA
        SynList[-1].tau_d_NMDA=TAU_2_NMDA
        ConList[-1].weight[0] = NMDA_W
        ConList[-1].delay = DELAY
        SynList[-1].n_NMDA = N_NMDA
        SynList[-1].gama_NMDA = GAMMA_NMDA



    return SynList,ConList

# This function tests whether NMDA spike is "independent"
# independency of a spike (subunit) is defined if the voltage in the most proximal junction between 
# this terminal and any other activated terminal has never passed the voltage in VOLTAGE_THRESHOLD_NEAREST_JUNCTION
# see more details in Eyal et al.
def test_independance_of_NMDA_spikes(list_of_terminals,sec_voltage_dict,cell):

    success = 1
    for ix,seg1 in enumerate(list_of_terminals):
        sec1 = seg1.sec
        for jx,seg2 in enumerate(list_of_terminals[ix+1:]):
            sec2 = seg2.sec
            junction = nearest_junction(sec1,sec2,cell.soma[0])
            if np.max(np.array(sec_voltage_dict[junction]))>VOLTAGE_THRESHOLD_NEAREST_JUNCTION:
                print "fail on:"
                print sec1.hname()
                print sec2.hname()
                print 
                success = 0

    return success

h.load_file("../NEURON_color_maps/TColorMap.hoc")
h.load_file("movierun.hoc")

# For visualization
def create_plot_shape(rotation,view):

    ps = h.PlotShape() 
    ps.exec_menu("View = plot")
    ps.variable("v")
    cm1 = h.TColorMap("../NEURON_color_maps/jet.cm")


    cm1.set_color_map(ps,-90,-10)
    h.fast_flush_list.append(ps)
    ps.exec_menu("Shape Plot")
    ps.exec_menu("Show Diam")


    ps.exec_menu("Variable Scale")
    ps.rotate(rotation[0],rotation[1],rotation[2],rotation[3],rotation[4],rotation[5])

    ps.view(view[0],view[1],view[2],view[3],view[4],view[5],view[6],view[7])




def add_a_model(model_dict,SynList,ConList,sec_voltage_dict,x_shift):
    HCell = create_model(model_dict['model'],model_dict['morph'])

    # Moving the models in space. s.t. it will be possible to see all of them
    for sec in list(HCell.somatic)+list(HCell.basal)+list(HCell.apical):
        sec.push()
        for i in range(int(h.n3d())):
            h.pt3dchange(i,h.x3d(i)+x_shift,h.y3d(i),h.z3d(i),h.diam3d(i))

        h.pop_section()



    dict_syn_to_nmda_spike_file = model_dict['number_of_syns_per_seg_file']

    apic_list = model_dict['apic_list']
    basal_list = model_dict['basal_list']


    seg_to_num_syn_for_nmda_spike = seg_to_num_of_syn_per_nmda_spike_func(dict_syn_to_nmda_spike_file,HCell)

    nmda_tips = []
    for sec_ix in apic_list:
        nmda_tips.append(HCell.apic[sec_ix](SECTION_TERMINAL))

    for sec_ix in basal_list:
        nmda_tips.append(HCell.dend[sec_ix](SECTION_TERMINAL))

    add_synapses_on_list_of_segments(nmda_tips,HCell,SynList,ConList,seg_to_num_syn_for_nmda_spike)

    
    # A dictionary that map from all the model sections to the voltage recorded in the distal end of these sections
    for sec in [HCell.soma[0]]+list(HCell.basal)+list(HCell.apical):
        sec_voltage_dict[sec] = h.Vector()


    sec_voltage_dict[HCell.soma[0]].record(HCell.soma[0](.5)._ref_v)
    for sec in list(HCell.basal)+list(HCell.apical):
        sec_voltage_dict[sec].record(sec(1)._ref_v)

    return HCell,nmda_tips



# Run each model separately
# Models are created, and the synapses are distributed on them 
# Then it runs the simulation and the independency of the NMDA spikes in all the models is checked
# Finally visualize the six models similar to Figure S5

def run_models(model_names,models_dicts,plot_ms = 10,x_shift = 1000):
    Syn_Lists = {}
    Con_Lists = {}
    sec_voltage_dicts = {}

    for ix,model in enumerate(model_names):
        Syn_Lists[model] =[] 
        Con_Lists[model] =[] 
        sec_voltage_dicts[model] = {}
        HCell,nmda_tips = add_a_model(models_dicts[model],Syn_Lists[model],Con_Lists[model],sec_voltage_dicts[model],x_shift*ix)
        models_dicts[model]['nmda_tips'] = nmda_tips
        models_dicts[model]['HCell'] = HCell
    
    h.define_shape()

    h.v_init= V_INIT
    h.init (h.v_init)
    h.run()

    success_arr = []
    for ix,model in enumerate(model_names):
        success = test_independance_of_NMDA_spikes(models_dicts[model]['nmda_tips'],sec_voltage_dicts[model],models_dicts[model]['HCell'])

        if success:
            print model + " has " + str(len(models_dicts[model]['nmda_tips'])) + " independent NMDA spikes"

        else:
            print "Failure: The NMDA spikes are not independent in model "+model

        create_plot_shape(models_dicts[model]['ps_rotation'],models_dicts[model]['ps_view'])
        success_arr.append(success)


    h.tstop = Spike_time+plot_ms
    h.run()

    for ix,model in enumerate(model_names):
        HCell = models_dicts[model]['HCell'] 
        for sec in list(HCell.basal) + list(HCell.apical):
            sec.diam *=3 
    return success_arr


model_names = ["cell0603_03","cell0603_08","cell0603_11","cell1303_03","cell1303_05","cell1303_06"]
models_dicts = {}
models_dicts["cell0603_03"] = {"model":"cell0603_03_model_cm_0_49","morph":"../morphs/2013_03_06_cell03_789_H41_03.ASC",
        "number_of_syns_per_seg_file":"../number_of_synapses_to_NMDA_spike/dict_0603_03_seg_to_nmda_spike.pickle",
        "apic_list": [19,23,27,29,30,35,38,42,47,50,52,55,58,62,67,69,76,80],
        "basal_list" : [3,6,13,17,22,24,26,32,39,45,47,50,57,58],
        "ps_rotation" : [0,0,0,0,0,3.6],
        "ps_view" : [-300,-300,600,1200,0,0,400,800]}

models_dicts["cell0603_08"] = {"model":"cell0603_08_model_cm_0_45","morph":"../morphs/2013_03_06_cell08_876_H41_05_Cell2.ASC",
        "number_of_syns_per_seg_file":"../number_of_synapses_to_NMDA_spike/dict_0603_08_seg_to_nmda_spike.pickle",
        "apic_list": [6,11,16,29,38,42,44,47,53,56],
        "basal_list" : [2,5,16,19,35,40,47,59],
        "ps_rotation" : [0,0,0,0,0,0.87*pi],
        "ps_view" : [-2150,-1100,600,1200,150,0,400,800]}

models_dicts["cell0603_11"] = {"model":"cell0603_11_model_cm_0_44","morph":"../morphs/2013_03_06_cell11_1125_H41_06.ASC",
        "number_of_syns_per_seg_file":"../number_of_synapses_to_NMDA_spike/dict_0603_11_seg_to_nmda_spike.pickle",
        "apic_list": [7,18,24,35,40,45,50,54,62,64,71,81,96,100],
        "basal_list" : [16,20,25,35,43,49,68,82,88,97,114],
        "ps_rotation" : [0,0,0,0,0,1.1*pi],
        "ps_view" : [-4200,900,700,1500,300,0,400,800]}

models_dicts["cell1303_03"] = {"model":"cell1303_03_model_cm_0_43","morph":"../morphs/2013_03_13_cell03_1204_H42_02.ASC",
        "number_of_syns_per_seg_file":"../number_of_synapses_to_NMDA_spike/dict_1303_03_seg_to_nmda_spike.pickle",
        "apic_list": [20,22,24,28,37,44,47,51,58,65,74,82,90],
        "basal_list" : [11,22,29,46,48,61,68,87,91],
        "ps_rotation" : [0,0,0,0,0,0.05],
        "ps_view" : [5700,-600,650,1500,450,0,325,750]}

models_dicts["cell1303_05"] = {"model":"cell1303_05_model_cm_0_50","morph":"../morphs/2013_03_13_cell05_675_H42_04.ASC",
        "number_of_syns_per_seg_file":"../number_of_synapses_to_NMDA_spike/dict_1303_05_seg_to_nmda_spike.pickle",
        "apic_list": [15,23,25,26,31,38,40,50,53,67,75],
        "basal_list" : [5,9,14,23,27,37,43,53,58,60,65,68,77],
        "ps_rotation" : [0,0,0,0,0,-5*pi/16],
        "ps_view" : [4100,6300,600,800,600,0,350,700]}

models_dicts["cell1303_06"] = {"model":"cell1303_06_model_cm_0_52","morph":"../morphs/2013_03_13_cell06_945_H42_05.ASC",
        "number_of_syns_per_seg_file":"../number_of_synapses_to_NMDA_spike/dict_1303_06_seg_to_nmda_spike.pickle",
        "apic_list": [21,26,29,37,38,39,42,45,50,54,65,70],
        "basal_list" : [6,12,14,18,22,25,33,40,46,49,54,57,61,64,73,76],
        "ps_rotation" : [0,0,0,0,0,-pi/2-0.07],
        "ps_view" : [-1000,9600,600,1500,750,0,300,750]}




run_models(model_names,models_dicts)


